/*
 * Spine Runtimes Software License
 * Version 2.3
 *
 * Copyright (c) 2013-2015, Esoteric Software
 * All rights reserved.
 *
 * You are granted a perpetual, non-exclusive, non-sublicensable and
 * non-transferable license to use, install, execute and perform the Spine
 * Runtimes Software (the "Software") and derivative works solely for personal
 * or internal use. Without the written permission of Esoteric Software (see
 * Section 2 of the Spine Software License Agreement), you may not (a) modify,
 * translate, adapt or otherwise create derivative works, improvements of the
 * Software or develop new applications using the Software or (b) remove,
 * delete, alter or obscure any trademarks or any copyright, trademark, patent
 * or other intellectual property or proprietary rights notices on or in the
 * Software, including any copy thereof. Redistributions in binary or source
 * form must include this license and terms.
 *
 * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright 2016 Nicholas Bilyk
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Copyright 2016 Nicholas Bilyk
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Spine Runtimes Software License
 * Version 2.3
 *
 * Copyright (c) 2013-2015, Esoteric Software
 * All rights reserved.
 *
 * You are granted a perpetual, non-exclusive, non-sublicensable and
 * non-transferable license to use, install, execute and perform the Spine
 * Runtimes Software (the "Software") and derivative works solely for personal
 * or internal use. Without the written permission of Esoteric Software (see
 * Section 2 of the Spine Software License Agreement), you may not (a) modify,
 * translate, adapt or otherwise create derivative works, improvements of the
 * Software or develop new applications using the Software or (b) remove,
 * delete, alter or obscure any trademarks or any copyright, trademark, patent
 * or other intellectual property or proprietary rights notices on or in the
 * Software, including any copy thereof. Redistributions in binary or source
 * form must include this license and terms.
 *
 * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Spine Runtimes Software License
 * Version 2.3
 *
 * Copyright (c) 2013-2015, Esoteric Software
 * All rights reserved.
 *
 * You are granted a perpetual, non-exclusive, non-sublicensable and
 * non-transferable license to use, install, execute and perform the Spine
 * Runtimes Software (the "Software") and derivative works solely for personal
 * or internal use. Without the written permission of Esoteric Software (see
 * Section 2 of the Spine Software License Agreement), you may not (a) modify,
 * translate, adapt or otherwise create derivative works, improvements of the
 * Software or develop new applications using the Software or (b) remove,
 * delete, alter or obscure any trademarks or any copyright, trademark, patent
 * or other intellectual property or proprietary rights notices on or in the
 * Software, including any copy thereof. Redistributions in binary or source
 * form must include this license and terms.
 *
 * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Spine Runtimes Software License
 * Version 2.3
 *
 * Copyright (c) 2013-2015, Esoteric Software
 * All rights reserved.
 *
 * You are granted a perpetual, non-exclusive, non-sublicensable and
 * non-transferable license to use, install, execute and perform the Spine
 * Runtimes Software (the "Software") and derivative works solely for personal
 * or internal use. Without the written permission of Esoteric Software (see
 * Section 2 of the Spine Software License Agreement), you may not (a) modify,
 * translate, adapt or otherwise create derivative works, improvements of the
 * Software or develop new applications using the Software or (b) remove,
 * delete, alter or obscure any trademarks or any copyright, trademark, patent
 * or other intellectual property or proprietary rights notices on or in the
 * Software, including any copy thereof. Redistributions in binary or source
 * form must include this license and terms.
 *
 * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright 2016 Nicholas Bilyk
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

///*
// * Copyright 2016 Nicholas Bilyk
// *
// * Licensed under the Apache License, Version 2.0 (the "License");
// * you may not use this file except in compliance with the License.
// * You may obtain a copy of the License at
// *
// *     http://www.apache.org/licenses/LICENSE-2.0
// *
// * Unless required by applicable law or agreed to in writing, software
// * distributed under the License is distributed on an "AS IS" BASIS,
// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// * See the License for the specific language governing permissions and
// * limitations under the License.
// */
//
///*
// * Copyright 2016 Nicholas Bilyk
// *
// * Licensed under the Apache License, Version 2.0 (the "License");
// * you may not use this file except in compliance with the License.
// * You may obtain a copy of the License at
// *
// *     http://www.apache.org/licenses/LICENSE-2.0
// *
// * Unless required by applicable law or agreed to in writing, software
// * distributed under the License is distributed on an "AS IS" BASIS,
// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// * See the License for the specific language governing permissions and
// * limitations under the License.
// */.gdx.files.FileHandle
//import com.badlogic.gdx.graphics.Color
//import com.badlogic.gdx.graphics.g2d.TextureAtlas
//import com.badlogic.gdx.utils.Array
//import com.badlogic.gdx.utils.DataInput
//import com.badlogic.gdx.utils.FloatArray
//import com.badlogic.gdx.utils.IntArray
//import com.badlogic.gdx.utils.SerializationException
//import com.esotericsoftware.spine.animation.Animation.AttachmentTimeline
//import com.esotericsoftware.spine.animation.Animation.ColorTimeline
//import com.esotericsoftware.spine.animation.Animation.CurveTimeline
//import com.esotericsoftware.spine.animation.Animation.DrawOrderTimeline
//import com.esotericsoftware.spine.animation.Animation.EventTimeline
//import com.esotericsoftware.spine.animation.Animation.FfdTimeline
//import com.esotericsoftware.spine.animation.Animation.IkConstraintTimeline
//import com.esotericsoftware.spine.animation.Animation.RotateTimeline
//import com.esotericsoftware.spine.animation.Animation.ScaleTimeline
//import com.esotericsoftware.spine.animation.Animation.Timeline
//import com.esotericsoftware.spine.animation.Animation.TranslateTimeline
//import com.esotericsoftware.spine.SkeletonJson.LinkedMesh
//import com.esotericsoftware.spine.attachments.AtlasAttachmentLoader
//import com.esotericsoftware.spine.attachments.Attachment
//import com.esotericsoftware.spine.attachments.AttachmentLoader
//import com.esotericsoftware.spine.data.AttachmentType
//import com.esotericsoftware.spine.attachments.BoundingBoxAttachment
//import com.esotericsoftware.spine.attachments.MeshAttachment
//import com.esotericsoftware.spine.attachments.RegionAttachment
//import com.esotericsoftware.spine.attachments.WeightedMeshAttachment
//
//class SkeletonBinary {
//
//	private val attachmentLoader: AttachmentLoader
//	/** Scales the bones, images, and animations as they are loaded.  */
//	var scale = 1f
//	private val linkedMeshes = Array()
//
//	constructor(atlas: TextureAtlas) {
//		attachmentLoader = AtlasAttachmentLoader(atlas)
//	}
//
//	constructor(attachmentLoader: AttachmentLoader) {
//		this.attachmentLoader = attachmentLoader
//	}
//
//	fun readSkeletonData(file: FileHandle?): SkeletonData {
//		if (file == null) throw IllegalArgumentException("file cannot be null.")
//
//		val scale = this.scale
//
//		val skeletonData = SkeletonData()
//		skeletonData.name = file!!.nameWithoutExtension()
//
//		val input = object : DataInput(file!!.read(512)) {
//			private var chars = CharArray(32)
//
//			@Throws(IOException::class)
//			fun readString(): String? {
//				var byteCount = readInt(true)
//				when (byteCount) {
//					0 -> return null
//					1 -> return ""
//				}
//				byteCount--
//				if (chars.size < byteCount) chars = CharArray(byteCount)
//				val chars = this.chars
//				var charCount = 0
//				var i = 0
//				while (i < byteCount) {
//					val b = read()
//					when (b shr 4) {
//						12, 13 -> {
//							chars[charCount++] = (b and 0x1F shl 6 or (read() and 0x3F)) as Char
//							i += 2
//						}
//						14 -> {
//							chars[charCount++] = (b and 0x0F shl 12 or (read() and 0x3F) shl 6 or read() and 0x3F) as Char
//							i += 3
//						}
//						else -> {
//							chars[charCount++] = b.toChar()
//							i++
//						}
//					}
//				}
//				return String(chars, 0, charCount)
//			}
//		}
//		try {
//			skeletonData.hash = input.readString()
//			if (skeletonData.hash.isEmpty()) skeletonData.hash = null
//			skeletonData.version = input.readString()
//			if (skeletonData.version.isEmpty()) skeletonData.version = null
//			skeletonData.width = input.readFloat()
//			skeletonData.height = input.readFloat()
//
//			val nonessential = input.readBoolean()
//
//			if (nonessential) {
//				skeletonData.imagesPath = input.readString()
//				if (skeletonData.imagesPath.isEmpty()) skeletonData.imagesPath = null
//			}
//
//			// Bones.
//			run {
//				var i = 0
//				val n = input.readInt(true)
//				while (i < n) {
//					val name = input.readString()
//					val parent = if (i == 0) null else skeletonData.bones.get(input.readInt(true))
//					val boneData = BoneData(name, parent)
//					boneData.x = input.readFloat() * scale
//					boneData.y = input.readFloat() * scale
//					boneData.scaleX = input.readFloat()
//					boneData.scaleY = input.readFloat()
//					boneData.rotation = input.readFloat()
//					boneData.length = input.readFloat() * scale
//					boneData.inheritScale = input.readBoolean()
//					boneData.inheritRotation = input.readBoolean()
//					if (nonessential) Color.rgba8888ToColor(boneData.color, input.readInt())
//					skeletonData.bones.add(boneData)
//					i++
//				}
//			}
//
//			// IK constraints.
//			run {
//				var i = 0
//				val n = input.readInt(true)
//				while (i < n) {
//					val ikConstraintData = IkConstraintData(input.readString())
//					var ii = 0
//					val nn = input.readInt(true)
//					while (ii < nn) {
//						ikConstraintData.bones.add(skeletonData.bones.get(input.readInt(true)))
//						ii++
//					}
//					ikConstraintData.target = skeletonData.bones.get(input.readInt(true))
//					ikConstraintData.mix = input.readFloat()
//					ikConstraintData.bendDirection = input.readByte()
//					skeletonData.ikConstraints.add(ikConstraintData)
//					i++
//				}
//			}
//
//			// Transform constraints.
//			run {
//				var i = 0
//				val n = input.readInt(true)
//				while (i < n) {
//					val transformConstraintData = TransformConstraintData(input.readString())
//					transformConstraintData.bone = skeletonData.bones.get(input.readInt(true))
//					transformConstraintData.target = skeletonData.bones.get(input.readInt(true))
//					transformConstraintData.translateMix = input.readFloat()
//					transformConstraintData.x = input.readFloat()
//					transformConstraintData.y = input.readFloat()
//					skeletonData.transformConstraints.add(transformConstraintData)
//					i++
//				}
//			}
//
//			// Slots.
//			run {
//				var i = 0
//				val n = input.readInt(true)
//				while (i < n) {
//					val slotName = input.readString()
//					val boneData = skeletonData.bones.get(input.readInt(true))
//					val slotData = SlotData(slotName, boneData)
//					Color.rgba8888ToColor(slotData.color, input.readInt())
//					slotData.attachmentName = input.readString()
//					slotData.blendMode = BlendMode.values[input.readInt(true)]
//					skeletonData.slots.add(slotData)
//					i++
//				}
//			}
//
//			// Default skin.
//			val defaultSkin = readSkin(input, "default", nonessential)
//			if (defaultSkin != null) {
//				skeletonData.defaultSkin = defaultSkin
//				skeletonData.skins.add(defaultSkin)
//			}
//
//			// Skins.
//			run {
//				var i = 0
//				val n = input.readInt(true)
//				while (i < n) {
//					skeletonData.skins.add(readSkin(input, input.readString(), nonessential))
//					i++
//				}
//			}
//
//			// Linked meshes.
//			run {
//				var i = 0
//				val n = linkedMeshes.size
//				while (i < n) {
//					val linkedMesh = linkedMeshes.get(i)
//					val skin = if (linkedMesh.skin == null) skeletonData.defaultSkin else skeletonData.findSkin(linkedMesh.skin) ?: throw SerializationException("Skin not found: " + linkedMesh.skin!!)
//					val parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent) ?: throw SerializationException("Parent mesh not found: " + linkedMesh.parent)
//					if (linkedMesh.mesh is MeshAttachment) {
//						linkedMesh.mesh.parentMesh = parent as MeshAttachment?
//						linkedMesh.mesh.updateUVs()
//					} else {
//						linkedMesh.mesh.parentMesh = parent as WeightedMeshAttachment?
//						linkedMesh.mesh.updateUVs()
//					}
//					i++
//				}
//			}
//			linkedMeshes.clear()
//
//			// Events.
//			run {
//				var i = 0
//				val n = input.readInt(true)
//				while (i < n) {
//					val eventData = EventData(input.readString())
//					eventData.int = input.readInt(false)
//					eventData.float = input.readFloat()
//					eventData.string = input.readString()
//					skeletonData.events.add(eventData)
//					i++
//				}
//			}
//
//			// Animations.
//			var i = 0
//			val n = input.readInt(true)
//			while (i < n) {
//				readAnimation(input.readString(), input, skeletonData)
//				i++
//			}
//
//		} catch (ex: IOException) {
//			throw SerializationException("Error reading skeleton file.", ex)
//		} finally {
//			try {
//				input.close()
//			} catch (ignored: IOException) {
//			}
//
//		}
//
//		skeletonData.bones.shrink()
//		skeletonData.slots.shrink()
//		skeletonData.skins.shrink()
//		skeletonData.events.shrink()
//		skeletonData.animations.shrink()
//		skeletonData.ikConstraints.shrink()
//		return skeletonData
//	}
//
//	/** @return May be null.
//	 */
//	@Throws(IOException::class)
//	private fun readSkin(input: DataInput, skinName: String, nonessential: Boolean): Skin? {
//		val slotCount = input.readInt(true)
//		if (slotCount == 0) return null
//		val skin = Skin(skinName)
//		for (i in 0..slotCount - 1) {
//			val slotIndex = input.readInt(true)
//			var ii = 0
//			val nn = input.readInt(true)
//			while (ii < nn) {
//				val name = input.readString()
//				skin.addAttachment(slotIndex, name, readAttachment(input, skin, slotIndex, name, nonessential))
//				ii++
//			}
//		}
//		return skin
//	}
//
//	@Throws(IOException::class)
//	private fun readAttachment(input: DataInput, skin: Skin, slotIndex: Int, attachmentName: String, nonessential: Boolean): Attachment? {
//		val scale = this.scale
//
//		var name = input.readString()
//		if (name == null) name = attachmentName
//
//		val type = AttachmentType.values[input.readByte()]
//		when (type) {
//			AttachmentType.region -> {
//				var path = input.readString()
//				val x = input.readFloat()
//				val y = input.readFloat()
//				val scaleX = input.readFloat()
//				val scaleY = input.readFloat()
//				val rotation = input.readFloat()
//				val width = input.readFloat()
//				val height = input.readFloat()
//				val color = input.readInt()
//
//				if (path == null) path = name
//				val region = attachmentLoader.newRegionAttachment(skin, name, path) ?: return null
//				region.path = path
//				region.x = x * scale
//				region.y = y * scale
//				region.scaleX = scaleX
//				region.scaleY = scaleY
//				region.rotation = rotation
//				region.width = width * scale
//				region.height = height * scale
//				Color.rgba8888ToColor(region.color, color)
//				region.updateOffset()
//				return region
//			}
//			AttachmentType.boundingbox -> {
//				val vertices = readFloatArray(input, input.readInt(true) * 2, scale)
//				val box = attachmentLoader.newBoundingBoxAttachment(skin, name) ?: return null
//				box.vertices = vertices
//				return box
//			}
//			AttachmentType.mesh -> {
//				var path = input.readString()
//				val color = input.readInt()
//				var hullLength = 0
//				val verticesLength = input.readInt(true) * 2
//				val uvs = readFloatArray(input, verticesLength, 1f)
//				val triangles = readShortArray(input)
//				val vertices = readFloatArray(input, verticesLength, scale)
//				hullLength = input.readInt(true)
//				var edges: ShortArray? = null
//				var width = 0f
//				var height = 0f
//				if (nonessential) {
//					edges = readShortArray(input)
//					width = input.readFloat()
//					height = input.readFloat()
//				}
//
//				if (path == null) path = name
//				val mesh = attachmentLoader.newMeshAttachment(skin, name, path) ?: return null
//				mesh.path = path
//				Color.rgba8888ToColor(mesh.color, color)
//				mesh.vertices = vertices
//				mesh.triangles = triangles
//				mesh.regionUVs = uvs
//				mesh.updateUVs()
//				mesh.hullLength = hullLength * 2
//				if (nonessential) {
//					mesh.edges = edges
//					mesh.width = width * scale
//					mesh.height = height * scale
//				}
//				return mesh
//			}
//			AttachmentType.linkedmesh -> {
//				var path = input.readString()
//				val color = input.readInt()
//				val skinName = input.readString()
//				val parent = input.readString()
//				val inheritFfd = input.readBoolean()
//				var width = 0f
//				var height = 0f
//				if (nonessential) {
//					width = input.readFloat()
//					height = input.readFloat()
//				}
//
//				if (path == null) path = name
//				val mesh = attachmentLoader.newMeshAttachment(skin, name, path) ?: return null
//				mesh.path = path
//				Color.rgba8888ToColor(mesh.color, color)
//				mesh.inheritFfd = inheritFfd
//				if (nonessential) {
//					mesh.width = width * scale
//					mesh.height = height * scale
//				}
//				linkedMeshes.add(LinkedMesh(mesh, skinName, slotIndex, parent))
//				return mesh
//			}
//			AttachmentType.weightedmesh -> {
//				var path = input.readString()
//				val color = input.readInt()
//				val vertexCount = input.readInt(true)
//				val uvs = readFloatArray(input, vertexCount * 2, 1f)
//				val triangles = readShortArray(input)
//				val weights = FloatArray(uvs.size * 3 * 3)
//				val bones = IntArray(uvs.size * 3)
//				for (i in 0..vertexCount - 1) {
//					bones.add(input.readFloat())
//					for (ii in 0..input.readFloat() - 1) {
//						bones.add(input.readFloat() as Int)
//						weights.add(input.readFloat() * scale)
//						weights.add(input.readFloat() * scale)
//						weights.add(input.readFloat())
//					}
//				}
//				val hullLength = input.readInt(true)
//				var edges: ShortArray? = null
//				var width = 0f
//				var height = 0f
//				if (nonessential) {
//					edges = readShortArray(input)
//					width = input.readFloat()
//					height = input.readFloat()
//				}
//
//				if (path == null) path = name
//				val mesh = attachmentLoader.newWeightedMeshAttachment(skin, name, path) ?: return null
//				mesh.path = path
//				Color.rgba8888ToColor(mesh.color, color)
//				mesh.bones = bones.toArray()
//				mesh.weights = weights.toArray()
//				mesh.triangles = triangles
//				mesh.regionUVs = uvs
//				mesh.updateUVs()
//				mesh.hullLength = hullLength * 2
//				if (nonessential) {
//					mesh.edges = edges
//					mesh.width = width * scale
//					mesh.height = height * scale
//				}
//				return mesh
//			}
//			AttachmentType.weightedlinkedmesh -> {
//				var path = input.readString()
//				val color = input.readInt()
//				val skinName = input.readString()
//				val parent = input.readString()
//				val inheritFfd = input.readBoolean()
//				var width = 0f
//				var height = 0f
//				if (nonessential) {
//					width = input.readFloat()
//					height = input.readFloat()
//				}
//
//				if (path == null) path = name
//				val mesh = attachmentLoader.newWeightedMeshAttachment(skin, name, path) ?: return null
//				mesh.path = path
//				Color.rgba8888ToColor(mesh.color, color)
//				mesh.inheritFfd = inheritFfd
//				if (nonessential) {
//					mesh.width = width * scale
//					mesh.height = height * scale
//				}
//				linkedMeshes.add(LinkedMesh(mesh, skinName, slotIndex, parent))
//				return mesh
//			}
//		}
//		return null
//	}
//
//	@Throws(IOException::class)
//	private fun readFloatArray(input: DataInput, n: Int, scale: Float): FloatArray {
//		val array = FloatArray(n)
//		if (scale == 1f) {
//			for (i in 0..n - 1)
//				array[i] = input.readFloat()
//		} else {
//			for (i in 0..n - 1)
//				array[i] = input.readFloat() * scale
//		}
//		return array
//	}
//
//	@Throws(IOException::class)
//	private fun readShortArray(input: DataInput): ShortArray {
//		val n = input.readInt(true)
//		val array = ShortArray(n)
//		for (i in 0..n - 1)
//			array[i] = input.readShort()
//		return array
//	}
//
//	private fun readAnimation(name: String, input: DataInput, skeletonData: SkeletonData) {
//		val timelines = Array()
//		val scale = this.scale
//		var duration = 0f
//
//		try {
//			// Slot timelines.
//			run {
//				var i = 0
//				val n = input.readInt(true)
//				while (i < n) {
//					val slotIndex = input.readInt(true)
//					var ii = 0
//					val nn = input.readInt(true)
//					while (ii < nn) {
//						val timelineType = input.readByte()
//						val frameCount = input.readInt(true)
//						when (timelineType) {
//							TIMELINE_COLOR -> {
//								val timeline = ColorTimeline(frameCount)
//								timeline.slotIndex = slotIndex
//								for (frameIndex in 0..frameCount - 1) {
//									val time = input.readFloat()
//									Color.rgba8888ToColor(tempColor, input.readInt())
//									timeline.setFrame(frameIndex, time, tempColor.r, tempColor.g, tempColor.b, tempColor.a)
//									if (frameIndex < frameCount - 1) readCurve(input, frameIndex, timeline)
//								}
//								timelines.add(timeline)
//								duration = maxOf(duration, timeline.frames[frameCount * 5 - 5])
//							}
//							TIMELINE_ATTACHMENT -> {
//								val timeline = AttachmentTimeline(frameCount)
//								timeline.slotIndex = slotIndex
//								for (frameIndex in 0..frameCount - 1)
//									timeline.setFrame(frameIndex, input.readFloat(), input.readString())
//								timelines.add(timeline)
//								duration = maxOf(duration, timeline.frames[frameCount - 1])
//							}
//						}
//						ii++
//					}
//					i++
//				}
//			}
//
//			// Bone timelines.
//			run {
//				var i = 0
//				val n = input.readInt(true)
//				while (i < n) {
//					val boneIndex = input.readInt(true)
//					var ii = 0
//					val nn = input.readInt(true)
//					while (ii < nn) {
//						val timelineType = input.readByte()
//						val frameCount = input.readInt(true)
//						when (timelineType) {
//							TIMELINE_ROTATE -> {
//								val timeline = RotateTimeline(frameCount)
//								timeline.boneIndex = boneIndex
//								for (frameIndex in 0..frameCount - 1) {
//									timeline.setFrame(frameIndex, input.readFloat(), input.readFloat())
//									if (frameIndex < frameCount - 1) readCurve(input, frameIndex, timeline)
//								}
//								timelines.add(timeline)
//								duration = maxOf(duration, timeline.frames[frameCount * 2 - 2])
//							}
//							TIMELINE_TRANSLATE, TIMELINE_SCALE -> {
//								val timeline: TranslateTimeline
//								var timelineScale = 1f
//								if (timelineType == TIMELINE_SCALE)
//									timeline = ScaleTimeline(frameCount)
//								else {
//									timeline = TranslateTimeline(frameCount)
//									timelineScale = scale
//								}
//								timeline.boneIndex = boneIndex
//								for (frameIndex in 0..frameCount - 1) {
//									timeline.setFrame(frameIndex, input.readFloat(), input.readFloat() * timelineScale,
//											input.readFloat() * timelineScale)
//									if (frameIndex < frameCount - 1) readCurve(input, frameIndex, timeline)
//								}
//								timelines.add(timeline)
//								duration = maxOf(duration, timeline.frames[frameCount * 3 - 3])
//							}
//						}
//						ii++
//					}
//					i++
//				}
//			}
//
//			// IK timelines.
//			run {
//				var i = 0
//				val n = input.readInt(true)
//				while (i < n) {
//					val ikConstraint = skeletonData.ikConstraints.get(input.readInt(true))
//					val frameCount = input.readInt(true)
//					val timeline = IkConstraintTimeline(frameCount)
//					timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(ikConstraint, true)
//					for (frameIndex in 0..frameCount - 1) {
//						timeline.setFrame(frameIndex, input.readFloat(), input.readFloat(), input.readByte())
//						if (frameIndex < frameCount - 1) readCurve(input, frameIndex, timeline)
//					}
//					timelines.add(timeline)
//					duration = maxOf(duration, timeline.frames[frameCount * 3 - 3])
//					i++
//				}
//			}
//
//			// Ffd timelines.
//			run {
//				var i = 0
//				val n = input.readInt(true)
//				while (i < n) {
//					val skin = skeletonData.skins.get(input.readInt(true))
//					var ii = 0
//					val nn = input.readInt(true)
//					while (ii < nn) {
//						val slotIndex = input.readInt(true)
//						var iii = 0
//						val nnn = input.readInt(true)
//						while (iii < nnn) {
//							val attachment = skin.getAttachment(slotIndex, input.readString())
//							val frameCount = input.readInt(true)
//							val timeline = FfdTimeline(frameCount)
//							timeline.slotIndex = slotIndex
//							timeline.attachment = attachment
//							for (frameIndex in 0..frameCount - 1) {
//								val time = input.readFloat()
//
//								val vertices: FloatArray
//								val vertexCount: Int
//								if (attachment is MeshAttachment)
//									vertexCount = (attachment as MeshAttachment).vertices.size
//								else
//									vertexCount = (attachment as WeightedMeshAttachment).weights.size / 3 * 2
//
//								var end = input.readInt(true)
//								if (end == 0) {
//									if (attachment is MeshAttachment)
//										vertices = (attachment as MeshAttachment).vertices
//									else
//										vertices = FloatArray(vertexCount)
//								} else {
//									vertices = FloatArray(vertexCount)
//									val start = input.readInt(true)
//									end += start
//									if (scale == 1f) {
//										for (v in start..end - 1)
//											vertices[v] = input.readFloat()
//									} else {
//										for (v in start..end - 1)
//											vertices[v] = input.readFloat() * scale
//									}
//									if (attachment is MeshAttachment) {
//										val meshVertices = (attachment as MeshAttachment).vertices
//										var v = 0
//										val vn = vertices.size
//										while (v < vn) {
//											vertices[v] += meshVertices[v]
//											v++
//										}
//									}
//								}
//
//								timeline.setFrame(frameIndex, time, vertices)
//								if (frameIndex < frameCount - 1) readCurve(input, frameIndex, timeline)
//							}
//							timelines.add(timeline)
//							duration = maxOf(duration, timeline.frames[frameCount - 1])
//							iii++
//						}
//						ii++
//					}
//					i++
//				}
//			}
//
//			// Draw order timeline.
//			val drawOrderCount = input.readInt(true)
//			if (drawOrderCount > 0) {
//				val timeline = DrawOrderTimeline(drawOrderCount)
//				val slotCount = skeletonData.slots.size
//				for (i in 0..drawOrderCount - 1) {
//					val time = input.readFloat()
//					val offsetCount = input.readInt(true)
//					val drawOrder = IntArray(slotCount)
//					for (ii in slotCount - 1 downTo 0)
//						drawOrder[ii] = -1
//					val unchanged = IntArray(slotCount - offsetCount)
//					var originalIndex = 0
//					var unchangedIndex = 0
//					for (ii in 0..offsetCount - 1) {
//						val slotIndex = input.readInt(true)
//						// Collect unchanged items.
//						while (originalIndex != slotIndex)
//							unchanged[unchangedIndex++] = originalIndex++
//						// Set changed items.
//						drawOrder[originalIndex + input.readInt(true)] = originalIndex++
//					}
//					// Collect remaining unchanged items.
//					while (originalIndex < slotCount)
//						unchanged[unchangedIndex++] = originalIndex++
//					// Fill in unchanged items.
//					for (ii in slotCount - 1 downTo 0)
//						if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex]
//					timeline.setFrame(i, time, drawOrder)
//				}
//				timelines.add(timeline)
//				duration = maxOf(duration, timeline.frames[drawOrderCount - 1])
//			}
//
//			// Event timeline.
//			val eventCount = input.readInt(true)
//			if (eventCount > 0) {
//				val timeline = EventTimeline(eventCount)
//				for (i in 0..eventCount - 1) {
//					val time = input.readFloat()
//					val eventData = skeletonData.events.get(input.readInt(true))
//					val event = Event(time, eventData)
//					event.int = input.readInt(false)
//					event.float = input.readFloat()
//					event.string = if (input.readBoolean()) input.readString() else eventData.string
//					timeline.setFrame(i, event)
//				}
//				timelines.add(timeline)
//				duration = maxOf(duration, timeline.frames[eventCount - 1])
//			}
//		} catch (ex: IOException) {
//			throw SerializationException("Error reading skeleton file.", ex)
//		}
//
//		timelines.shrink()
//		skeletonData.animations.add(Animation(name, timelines, duration))
//	}
//
//	@Throws(IOException::class)
//	private fun readCurve(input: DataInput, frameIndex: Int, timeline: CurveTimeline) {
//		when (input.readByte()) {
//			CURVE_STEPPED -> timeline.setStepped(frameIndex)
//			CURVE_BEZIER -> setCurve(timeline, frameIndex, input.readFloat(), input.readFloat(), input.readFloat(), input.readFloat())
//		}
//	}
//
//	internal fun setCurve(timeline: CurveTimeline, frameIndex: Int, cx1: Float, cy1: Float, cx2: Float, cy2: Float) {
//		timeline.setCurve(frameIndex, cx1, cy1, cx2, cy2)
//	}
//
//	companion object {
//		val TIMELINE_SCALE = 0
//		val TIMELINE_ROTATE = 1
//		val TIMELINE_TRANSLATE = 2
//		val TIMELINE_ATTACHMENT = 3
//		val TIMELINE_COLOR = 4
//
//		val CURVE_LINEAR = 0
//		val CURVE_STEPPED = 1
//		val CURVE_BEZIER = 2
//
//		private val tempColor = Color()
//	}
//}
