/*
 * Spine Runtimes Software License
 * Version 2.3
 *
 * Copyright (c) 2013-2015, Esoteric Software
 * All rights reserved.
 *
 * You are granted a perpetual, non-exclusive, non-sublicensable and
 * non-transferable license to use, install, execute and perform the Spine
 * Runtimes Software (the "Software") and derivative works solely for personal
 * or internal use. Without the written permission of Esoteric Software (see
 * Section 2 of the Spine Software License Agreement), you may not (a) modify,
 * translate, adapt or otherwise create derivative works, improvements of the
 * Software or develop new applications using the Software or (b) remove,
 * delete, alter or obscure any trademarks or any copyright, trademark, patent
 * or other intellectual property or proprietary rights notices on or in the
 * Software, including any copy thereof. Redistributions in binary or source
 * form must include this license and terms.
 *
 * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright 2016 Nicholas Bilyk
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Copyright 2016 Nicholas Bilyk
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Spine Runtimes Software License
 * Version 2.3
 *
 * Copyright (c) 2013-2015, Esoteric Software
 * All rights reserved.
 *
 * You are granted a perpetual, non-exclusive, non-sublicensable and
 * non-transferable license to use, install, execute and perform the Spine
 * Runtimes Software (the "Software") and derivative works solely for personal
 * or internal use. Without the written permission of Esoteric Software (see
 * Section 2 of the Spine Software License Agreement), you may not (a) modify,
 * translate, adapt or otherwise create derivative works, improvements of the
 * Software or develop new applications using the Software or (b) remove,
 * delete, alter or obscure any trademarks or any copyright, trademark, patent
 * or other intellectual property or proprietary rights notices on or in the
 * Software, including any copy thereof. Redistributions in binary or source
 * form must include this license and terms.
 *
 * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Spine Runtimes Software License
 * Version 2.3
 *
 * Copyright (c) 2013-2015, Esoteric Software
 * All rights reserved.
 *
 * You are granted a perpetual, non-exclusive, non-sublicensable and
 * non-transferable license to use, install, execute and perform the Spine
 * Runtimes Software (the "Software") and derivative works solely for personal
 * or internal use. Without the written permission of Esoteric Software (see
 * Section 2 of the Spine Software License Agreement), you may not (a) modify,
 * translate, adapt or otherwise create derivative works, improvements of the
 * Software or develop new applications using the Software or (b) remove,
 * delete, alter or obscure any trademarks or any copyright, trademark, patent
 * or other intellectual property or proprietary rights notices on or in the
 * Software, including any copy thereof. Redistributions in binary or source
 * form must include this license and terms.
 *
 * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Spine Runtimes Software License
 * Version 2.3
 *
 * Copyright (c) 2013-2015, Esoteric Software
 * All rights reserved.
 *
 * You are granted a perpetual, non-exclusive, non-sublicensable and
 * non-transferable license to use, install, execute and perform the Spine
 * Runtimes Software (the "Software") and derivative works solely for personal
 * or internal use. Without the written permission of Esoteric Software (see
 * Section 2 of the Spine Software License Agreement), you may not (a) modify,
 * translate, adapt or otherwise create derivative works, improvements of the
 * Software or develop new applications using the Software or (b) remove,
 * delete, alter or obscure any trademarks or any copyright, trademark, patent
 * or other intellectual property or proprietary rights notices on or in the
 * Software, including any copy thereof. Redistributions in binary or source
 * form must include this license and terms.
 *
 * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright 2016 Nicholas Bilyk
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

///*
// * Copyright 2016 Nicholas Bilyk
// *
// * Licensed under the Apache License, Version 2.0 (the "License");
// * you may not use this file except in compliance with the License.
// * You may obtain a copy of the License at
// *
// *     http://www.apache.org/licenses/LICENSE-2.0
// *
// * Unless required by applicable law or agreed to in writing, software
// * distributed under the License is distributed on an "AS IS" BASIS,
// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// * See the License for the specific language governing permissions and
// * limitations under the License.
// */
//
///*
// * Copyright 2016 Nicholas Bilyk
// *
// * Licensed under the Apache License, Version 2.0 (the "License");
// * you may not use this file except in compliance with the License.
// * You may obtain a copy of the License at
// *
// *     http://www.apache.org/licenses/LICENSE-2.0
// *
// * Unless required by applicable law or agreed to in writing, software
// * distributed under the License is distributed on an "AS IS" BASIS,
// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// * See the License for the specific language governing permissions and
// * limitations under the License.
// */
//
//
//package com.esotericsoftware.spine
//
//import com.acornui.graphic.Color
//import com.esotericsoftware.spine.attachments.MeshAttachment
//import com.esotericsoftware.spine.attachments.RegionAttachment
//import com.esotericsoftware.spine.attachments.WeightedMeshAttachment
//
//import com.badlogic.gdx.graphics.g2d.Batch.*
//
//import com.badlogic.gdx.Gdx
//import com.badlogic.gdx.graphics.Color
//import com.badlogic.gdx.graphics.GL20
//import com.badlogic.gdx.graphics.glutils.ShapeRenderer
//import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType
//import com.badlogic.gdx.utils.Array
//import com.badlogic.gdx.utils.FloatArray
//
//class SkeletonRendererDebug {
//
//	val shapeRenderer: ShapeRenderer
//	private var drawBones = true
//	private var drawRegionAttachments = true
//	private var drawBoundingBoxes = true
//	private var drawMeshHull = true
//	private var drawMeshTriangles = true
//	private val bounds = SkeletonBounds()
//	private var scale = 1f
//	private val boneWidth = 2f
//	private var premultipliedAlpha: Boolean = false
//
//	constructor() {
//		shapeRenderer = ShapeRenderer()
//	}
//
//	constructor(shapes: ShapeRenderer) {
//		this.shapeRenderer = shapes
//	}
//
//	fun draw(skeleton: Skeleton) {
//		val skeletonX = skeleton.x
//		val skeletonY = skeleton.y
//
//		Gdx.gl.glEnable(GL20.GL_BLEND)
//		val srcFunc = if (premultipliedAlpha) GL20.GL_ONE else GL20.GL_SRC_ALPHA
//		Gdx.gl.glBlendFunc(srcFunc, GL20.GL_ONE_MINUS_SRC_ALPHA)
//
//		val shapes = this.shapeRenderer
//
//		val bones = skeleton.bones
//		if (drawBones) {
//			shapes.setColor(boneLineColor)
//			shapes.begin(ShapeType.Filled)
//			var i = 0
//			val n = bones.size
//			while (i < n) {
//				val bone = bones.get(i)
//				if (bone.parent == null) {
//					i++
//					continue
//				}
//				val x = skeletonX + bone.data.length * bone.a + bone.worldX
//				val y = skeletonY + bone.data.length * bone.c + bone.worldY
//				shapes.rectLine(skeletonX + bone.worldX, skeletonY + bone.worldY, x, y, boneWidth * scale)
//				i++
//			}
//			shapes.end()
//			shapes.begin(ShapeType.Line)
//			shapes.x(skeletonX, skeletonY, 4 * scale)
//		} else
//			shapes.begin(ShapeType.Line)
//
//		if (drawRegionAttachments) {
//			shapes.setColor(attachmentLineColor)
//			val slots = skeleton.slots
//			var i = 0
//			val n = slots.size
//			while (i < n) {
//				val slot = slots.get(i)
//				val attachment = slot.attachment
//				if (attachment is RegionAttachment) {
//					val vertices = attachment.updateWorldVertices(slot, false)
//					shapes.line(vertices[X1], vertices[Y1], vertices[X2], vertices[Y2])
//					shapes.line(vertices[X2], vertices[Y2], vertices[X3], vertices[Y3])
//					shapes.line(vertices[X3], vertices[Y3], vertices[X4], vertices[Y4])
//					shapes.line(vertices[X4], vertices[Y4], vertices[X1], vertices[Y1])
//				}
//				i++
//			}
//		}
//
//		if (drawMeshHull || drawMeshTriangles) {
//			val slots = skeleton.slots
//			var i = 0
//			val n = slots.size
//			while (i < n) {
//				val slot = slots.get(i)
//				val attachment = slot.attachment
//				var vertices: FloatArray? = null
//				var triangles: ShortArray? = null
//				var hullLength = 0
//				if (attachment is MeshAttachment) {
//					attachment.updateWorldVertices(slot, false)
//					vertices = attachment.worldVertices
//					triangles = attachment.triangles
//					hullLength = attachment.hullLength
//				} else if (attachment is WeightedMeshAttachment) {
//					attachment.updateWorldVertices(slot, false)
//					vertices = attachment.worldVertices
//					triangles = attachment.triangles
//					hullLength = attachment.hullLength
//				}
//				if (vertices == null || triangles == null) {
//					i++
//					continue
//				}
//				if (drawMeshTriangles) {
//					shapes.setColor(triangleLineColor)
//					var ii = 0
//					val nn = triangles.size
//					while (ii < nn) {
//						val v1 = triangles[ii] * 5
//						val v2 = triangles[ii + 1] * 5
//						val v3 = triangles[ii + 2] * 5
//						shapes.triangle(vertices[v1], vertices[v1 + 1], //
//								vertices[v2], vertices[v2 + 1], //
//								vertices[v3], vertices[v3 + 1] //
//						)
//						ii += 3
//					}
//				}
//				if (drawMeshHull && hullLength > 0) {
//					shapes.setColor(attachmentLineColor)
//					hullLength = hullLength / 2 * 5
//					var lastX = vertices[hullLength - 5]
//					var lastY = vertices[hullLength - 4]
//					var ii = 0
//					val nn = hullLength
//					while (ii < nn) {
//						val x = vertices[ii]
//						val y = vertices[ii + 1]
//						shapes.line(x, y, lastX, lastY)
//						lastX = x
//						lastY = y
//						ii += 5
//					}
//				}
//				i++
//			}
//		}
//
//		if (drawBoundingBoxes) {
//			val bounds = this.bounds
//			bounds.update(skeleton, true)
//			shapes.setColor(aabbColor)
//			shapes.rect(bounds.minX, bounds.minY, bounds.width, bounds.height)
//			shapes.setColor(boundingBoxColor)
//			val polygons = bounds.polygons
//			var i = 0
//			val n = polygons.size
//			while (i < n) {
//				val polygon = polygons.get(i)
//				shapes.polygon(polygon.items, 0, polygon.size)
//				i++
//			}
//		}
//
//		shapes.end()
//		shapes.begin(ShapeType.Filled)
//
//		if (drawBones) {
//			shapes.setColor(boneOriginColor)
//			var i = 0
//			val n = bones.size
//			while (i < n) {
//				val bone = bones.get(i)
//				shapes.setColor(Color.GREEN)
//				shapes.circle(skeletonX + bone.worldX, skeletonY + bone.worldY, 3 * scale, 8)
//				i++
//			}
//		}
//
//		shapes.end()
//	}
//
//	fun setBones(bones: Boolean) {
//		this.drawBones = bones
//	}
//
//	fun setScale(scale: Float) {
//		this.scale = scale
//	}
//
//	fun setRegionAttachments(regionAttachments: Boolean) {
//		this.drawRegionAttachments = regionAttachments
//	}
//
//	fun setBoundingBoxes(boundingBoxes: Boolean) {
//		this.drawBoundingBoxes = boundingBoxes
//	}
//
//	fun setMeshHull(meshHull: Boolean) {
//		this.drawMeshHull = meshHull
//	}
//
//	fun setMeshTriangles(meshTriangles: Boolean) {
//		this.drawMeshTriangles = meshTriangles
//	}
//
//	fun setPremultipliedAlpha(premultipliedAlpha: Boolean) {
//		this.premultipliedAlpha = premultipliedAlpha
//	}
//
//	companion object {
//		private val boneLineColor = Color.RED.copy()
//		private val boneOriginColor = Color.GREEN.copy()
//		private val attachmentLineColor = Color(0f, 0f, 1f, 0.5f)
//		private val triangleLineColor = Color(1f, 0.64f, 0f, 0.5f)
//		private val boundingBoxColor = Color(0f, 1f, 0f, 0.8f)
//		private val aabbColor = Color(0f, 1f, 0f, 0.5f)
//	}
//}
