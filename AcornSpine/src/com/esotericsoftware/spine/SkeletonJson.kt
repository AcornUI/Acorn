/*
 * Spine Runtimes Software License
 * Version 2.3
 *
 * Copyright (c) 2013-2015, Esoteric Software
 * All rights reserved.
 *
 * You are granted a perpetual, non-exclusive, non-sublicensable and
 * non-transferable license to use, install, execute and perform the Spine
 * Runtimes Software (the "Software") and derivative works solely for personal
 * or internal use. Without the written permission of Esoteric Software (see
 * Section 2 of the Spine Software License Agreement), you may not (a) modify,
 * translate, adapt or otherwise create derivative works, improvements of the
 * Software or develop new applications using the Software or (b) remove,
 * delete, alter or obscure any trademarks or any copyright, trademark, patent
 * or other intellectual property or proprietary rights notices on or in the
 * Software, including any copy thereof. Redistributions in binary or source
 * form must include this license and terms.
 *
 * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright 2016 Nicholas Bilyk
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Copyright 2016 Nicholas Bilyk
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Spine Runtimes Software License
 * Version 2.3
 *
 * Copyright (c) 2013-2015, Esoteric Software
 * All rights reserved.
 *
 * You are granted a perpetual, non-exclusive, non-sublicensable and
 * non-transferable license to use, install, execute and perform the Spine
 * Runtimes Software (the "Software") and derivative works solely for personal
 * or internal use. Without the written permission of Esoteric Software (see
 * Section 2 of the Spine Software License Agreement), you may not (a) modify,
 * translate, adapt or otherwise create derivative works, improvements of the
 * Software or develop new applications using the Software or (b) remove,
 * delete, alter or obscure any trademarks or any copyright, trademark, patent
 * or other intellectual property or proprietary rights notices on or in the
 * Software, including any copy thereof. Redistributions in binary or source
 * form must include this license and terms.
 *
 * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Spine Runtimes Software License
 * Version 2.3
 *
 * Copyright (c) 2013-2015, Esoteric Software
 * All rights reserved.
 *
 * You are granted a perpetual, non-exclusive, non-sublicensable and
 * non-transferable license to use, install, execute and perform the Spine
 * Runtimes Software (the "Software") and derivative works solely for personal
 * or internal use. Without the written permission of Esoteric Software (see
 * Section 2 of the Spine Software License Agreement), you may not (a) modify,
 * translate, adapt or otherwise create derivative works, improvements of the
 * Software or develop new applications using the Software or (b) remove,
 * delete, alter or obscure any trademarks or any copyright, trademark, patent
 * or other intellectual property or proprietary rights notices on or in the
 * Software, including any copy thereof. Redistributions in binary or source
 * form must include this license and terms.
 *
 * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Spine Runtimes Software License
 * Version 2.3
 *
 * Copyright (c) 2013-2015, Esoteric Software
 * All rights reserved.
 *
 * You are granted a perpetual, non-exclusive, non-sublicensable and
 * non-transferable license to use, install, execute and perform the Spine
 * Runtimes Software (the "Software") and derivative works solely for personal
 * or internal use. Without the written permission of Esoteric Software (see
 * Section 2 of the Spine Software License Agreement), you may not (a) modify,
 * translate, adapt or otherwise create derivative works, improvements of the
 * Software or develop new applications using the Software or (b) remove,
 * delete, alter or obscure any trademarks or any copyright, trademark, patent
 * or other intellectual property or proprietary rights notices on or in the
 * Software, including any copy thereof. Redistributions in binary or source
 * form must include this license and terms.
 *
 * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright 2016 Nicholas Bilyk
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

///*
// * Copyright 2016 Nicholas Bilyk
// *
// * Licensed under the Apache License, Version 2.0 (the "License");
// * you may not use this file except in compliance with the License.
// * You may obtain a copy of the License at
// *
// *     http://www.apache.org/licenses/LICENSE-2.0
// *
// * Unless required by applicable law or agreed to in writing, software
// * distributed under the License is distributed on an "AS IS" BASIS,
// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// * See the License for the specific language governing permissions and
// * limitations under the License.
// */
//
//
//package com.esotericsoftware.spine
//
//import com.acornui.core.graphics.BlendMode
//import com.acornui.core.graphics.TextureAtlasData
//import com.acornui.core.io.file.FileEntry
//import com.acornui.graphics.Color
//import com.esotericsoftware.spine.animation.Animation.*
//import com.esotericsoftware.spine.attachments.*
//
//
//class SkeletonJson {
//
//	private val attachmentLoader: AttachmentLoader
//
//	/** Scales the bones, images, and animations as they are loaded.  */
//	var scale = 1f
//
//	private val linkedMeshes = ArrayList<LinkedMesh>()
//
//	constructor(atlas: TextureAtlasData) {
//		attachmentLoader = AtlasAttachmentLoader(atlas)
//	}
//
//	constructor(attachmentLoader: AttachmentLoader) {
//		this.attachmentLoader = attachmentLoader
//	}
//
//	fun readSkeletonData(file: FileEntry): SkeletonData {
//
//		val scale = this.scale
//
//		val skeletonData = SkeletonData()
//		skeletonData.name = file.nameNoExtension()
//
//		val root = JsonReader().parse(file)
//
//		// Skeleton.
//		val skeletonMap = root.get("skeleton")
//		if (skeletonMap != null) {
//			skeletonData.hash = skeletonMap!!.getString("hash", null)
//			skeletonData.version = skeletonMap!!.getString("spine", null)
//			skeletonData.width = skeletonMap!!.getFloat("width", 0)
//			skeletonData.height = skeletonMap!!.getFloat("height", 0)
//			skeletonData.imagesPath = skeletonMap!!.getString("images", null)
//		}
//
//		// Bones.
//		run {
//			var boneMap = root.getChild("bones")
//			while (boneMap != null) {
//				var parent: BoneData? = null
//				val parentName = boneMap!!.getString("parent", null)
//				if (parentName != null) {
//					parent = skeletonData.findBone(parentName)
//					if (parent == null) throw Exception("Parent bone not found: " + parentName!!)
//				}
//				val boneData = BoneData(boneMap!!.getString("name"), parent)
//				boneData.length = boneMap!!.getFloat("length", 0) * scale
//				boneData.x = boneMap!!.getFloat("x", 0) * scale
//				boneData.y = boneMap!!.getFloat("y", 0) * scale
//				boneData.rotation = boneMap!!.getFloat("rotation", 0)
//				boneData.scaleX = boneMap!!.getFloat("scaleX", 1)
//				boneData.scaleY = boneMap!!.getFloat("scaleY", 1)
//				boneData.inheritScale = boneMap!!.getBoolean("inheritScale", true)
//				boneData.inheritRotation = boneMap!!.getBoolean("inheritRotation", true)
//
//				val color = boneMap!!.getString("color", null)
//				if (color != null) boneData.color.set(Color.fromStr(color))
//
//				skeletonData.bones.add(boneData)
//				boneMap = boneMap!!.next
//			}
//		}
//
//		// IK constraints.
//		var ikMap = root.getChild("ik")
//		while (ikMap != null) {
//			val ikConstraintData = IkConstraintData(ikMap!!.getString("name"))
//
//			var boneMap = ikMap!!.getChild("bones")
//			while (boneMap != null) {
//				val boneName = boneMap!!.asString()
//				val bone = skeletonData.findBone(boneName) ?: throw Exception("IK bone not found: $boneName")
//				ikConstraintData.bones.add(bone)
//				boneMap = boneMap!!.next
//			}
//
//			val targetName = ikMap!!.getString("target")
//			ikConstraintData.target = skeletonData.findBone(targetName) ?: throw Exception("Target bone not found: $targetName")
//
//			ikConstraintData.bendDirection = if (ikMap!!.getBoolean("bendPositive", true)) 1 else -1
//			ikConstraintData.mix = ikMap!!.getFloat("mix", 1)
//
//			skeletonData.ikConstraints.add(ikConstraintData)
//			ikMap = ikMap!!.next
//		}
//
//		// Transform constraints.
//		var transformMap = root.getChild("transform")
//		while (transformMap != null) {
//			val transformConstraintData = TransformConstraintData(transformMap!!.getString("name"))
//
//			val boneName = transformMap!!.getString("bone")
//			transformConstraintData.bone = skeletonData.findBone(boneName) ?: throw Exception("Bone not found: $boneName")
//
//			val targetName = transformMap!!.getString("target")
//			transformConstraintData.target = skeletonData.findBone(targetName)?: throw Exception("Bone not found: $targetName")
//
//			transformConstraintData.translateMix = transformMap!!.getFloat("translateMix", 1)
//			transformConstraintData.x = transformMap!!.getFloat("x", 0) * scale
//			transformConstraintData.y = transformMap!!.getFloat("y", 0) * scale
//
//			skeletonData.transformConstraints.add(transformConstraintData)
//			transformMap = transformMap!!.next
//		}
//
//		// Slots.
//		var slotMap = root.getChild("slots")
//		while (slotMap != null) {
//			val slotName = slotMap!!.getString("name")
//			val boneName = slotMap!!.getString("bone")
//			val boneData = skeletonData.findBone(boneName) ?: throw Exception("Slot bone not found: " + boneName)
//			val slotData = SlotData(slotName, boneData)
//
//			val color = slotMap!!.getString("color", null)
//			if (color != null) slotData.color.set(Color.fromStr(color))
//
//			slotData.attachmentName = slotMap!!.getString("attachment", null)
//			slotData.blendMode = BlendMode.valueOf(slotMap!!.getString("blend", BlendMode.NORMAL.name).toUpperCase())
//			skeletonData.slots.add(slotData)
//			slotMap = slotMap!!.next
//		}
//
//		// Skins.
//		var skinMap = root.getChild("skins")
//		while (skinMap != null) {
//			val skin = Skin(skinMap!!.name)
//			var slotEntry = skinMap!!.child
//			while (slotEntry != null) {
//				val slotIndex = skeletonData.findSlotIndex(slotEntry!!.name)
//				if (slotIndex == -1) throw Exception("Slot not found: " + slotEntry!!.name)
//				var entry = slotEntry!!.child
//				while (entry != null) {
//					val attachment = readAttachment(skin, slotIndex, entry!!.name, entry)
//					if (attachment != null) skin.addAttachment(slotIndex, entry!!.name, attachment)
//					entry = entry!!.next
//				}
//				slotEntry = slotEntry!!.next
//			}
//			skeletonData.skins.add(skin)
//			if (skin.name == "default") skeletonData.defaultSkin = skin
//			skinMap = skinMap!!.next
//		}
//
//		// Linked meshes.
//		var i = 0
//		val n = linkedMeshes.size
//		while (i < n) {
//			val linkedMesh = linkedMeshes[i]
//			val skin = if (linkedMesh.skin == null) skeletonData.defaultSkin!! else skeletonData.findSkin(linkedMesh.skin) ?: throw Exception("Skin not found: " + linkedMesh.skin!!)
//			val parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent) ?: throw Exception("Parent mesh not found: " + linkedMesh.parent)
//			if (linkedMesh.mesh is MeshAttachment) {
//				linkedMesh.mesh.parentMesh = parent as MeshAttachment?
//				linkedMesh.mesh.updateUVs()
//			} else if (linkedMesh.mesh is WeightedMeshAttachment) {
//				linkedMesh.mesh.parentMesh = parent as WeightedMeshAttachment?
//				linkedMesh.mesh.updateUVs()
//			}
//			i++
//		}
//		linkedMeshes.clear()
//
//		// Events.
//		var eventMap = root.getChild("events")
//		while (eventMap != null) {
//			val eventData = EventData(eventMap!!.name)
//			eventData.int = eventMap!!.getInt("int", 0)
//			eventData.float = eventMap!!.getFloat("float", 0f)
//			eventData.string = eventMap!!.getString("string", null)
//			skeletonData.events.add(eventData)
//			eventMap = eventMap!!.next
//		}
//
//		// Animations.
//		var animationMap = root.getChild("animations")
//		while (animationMap != null) {
//			readAnimation(animationMap!!.name, animationMap, skeletonData)
//			animationMap = animationMap!!.next
//		}
//
//		return skeletonData
//	}
//
//	private fun readAttachment(skin: Skin, slotIndex: Int, name: String, map: JsonValue): Attachment? {
//		var name = name
//		val scale = this.scale
//		name = map.getString("name", name)
//		val path = map.getString("path", name)
//
//		var type = map.getString("type", AttachmentType.region.name)
//		if (type == "skinnedmesh") type = "weightedmesh"
//		when (AttachmentType.valueOf(type)) {
//			AttachmentType.region -> {
//				val region = attachmentLoader.newRegionAttachment(name, path) ?: return null
//				region.path = path
//				region.x = map.getFloat("x", 0) * scale
//				region.y = map.getFloat("y", 0) * scale
//				region.scaleX = map.getFloat("scaleX", 1)
//				region.scaleY = map.getFloat("scaleY", 1)
//				region.rotation = map.getFloat("rotation", 0)
//				region.width = map.getFloat("width") * scale
//				region.height = map.getFloat("height") * scale
//
//				val color = map.getString("color", null)
//				if (color != null) region.color.set(Color.fromStr(color))
//
//				region.updateOffset()
//				return region
//			}
//			AttachmentType.boundingbox -> {
//				val box = attachmentLoader.newBoundingBoxAttachment(name) ?: return null
//				val vertices = map.require("vertices").asFloatArray()
//				if (scale != 1f) {
//					var i = 0
//					val n = vertices.size
//					while (i < n) {
//						vertices[i] *= scale
//						i++
//					}
//				}
//				box.vertices = vertices
//				return box
//			}
//			AttachmentType.mesh, AttachmentType.linkedmesh -> {
//				val mesh = attachmentLoader.newMeshAttachment(name, path) ?: return null
//				mesh.path = path
//
//				val color = map.getString("color", null)
//				if (color != null) mesh.color.set(Color.fromStr(color))
//
//				mesh.width = map.getFloat("width", 0) * scale
//				mesh.height = map.getFloat("height", 0) * scale
//
//				val parent = map.getString("parent", null)
//				if (parent == null) {
//					val vertices = map.require("vertices").asFloatArray()
//					if (scale != 1f) {
//						var i = 0
//						val n = vertices.size
//						while (i < n) {
//							vertices[i] *= scale
//							i++
//						}
//					}
//					mesh.vertices = vertices
//					mesh.triangles = map.require("triangles").asShortArray()
//					mesh.regionUVs = map.require("uvs").asFloatArray()
//					mesh.updateUVs()
//
//					if (map.has("hull")) mesh.hullLength = map.require("hull").asInt() * 2
//					if (map.has("edges")) mesh.edges = map.require("edges").asShortArray()
//				} else {
//					mesh.inheritFfd = map.getBoolean("ffd", true)
//					linkedMeshes.add(LinkedMesh(mesh, map.getString("skin", null), slotIndex, parent))
//				}
//				return mesh
//			}
//			AttachmentType.weightedmesh, AttachmentType.weightedlinkedmesh -> {
//				val mesh = attachmentLoader.newWeightedMeshAttachment(name, path) ?: return null
//				mesh.path = path
//
//				val color = map.getString("color", null)
//				if (color != null) mesh.color.set(Color.fromStr(color))
//
//				mesh.width = map.getFloat("width", 0) * scale
//				mesh.height = map.getFloat("height", 0) * scale
//
//				val parent = map.getString("parent", null)
//				if (parent == null) {
//					val uvs = map.require("uvs").asFloatArray()
//					val vertices = map.require("vertices").asFloatArray()
//					val weights = FloatArray(uvs.size * 3 * 3)
//					val bones = IntArray(uvs.size * 3)
//					var i = 0
//					val n = vertices.size
//					while (i < n) {
//						val boneCount = vertices[i++].toInt()
//						bones.add(boneCount)
//						val nn = i + boneCount * 4
//						while (i < nn) {
//							bones.add(vertices[i].toInt())
//							weights.add(vertices[i + 1] * scale)
//							weights.add(vertices[i + 2] * scale)
//							weights.add(vertices[i + 3])
//							i += 4
//						}
//					}
//					mesh.bones = bones.toArray()
//					mesh.weights = weights.toArray()
//					mesh.triangles = map.require("triangles").asShortArray()
//					mesh.regionUVs = uvs
//					mesh.updateUVs()
//
//					if (map.has("hull")) mesh.hullLength = map.require("hull").asInt() * 2
//					if (map.has("edges")) mesh.edges = map.require("edges").asShortArray()
//				} else {
//					mesh.inheritFfd = map.getBoolean("ffd", true)
//					linkedMeshes.add(LinkedMesh(mesh, map.getString("skin", null), slotIndex, parent))
//				}
//				return mesh
//			}
//		}
//
//		// RegionSequenceAttachment regionSequenceAttachment = (RegionSequenceAttachment)attachment;
//		//
//		// float fps = map.getFloat("fps");
//		// regionSequenceAttachment.setFrameTime(fps);
//		//
//		// String modeString = map.getString("mode");
//		// regionSequenceAttachment.setMode(modeString == null ? Mode.forward : Mode.valueOf(modeString));
//
//		return null
//	}
//
//	private fun readAnimation(name: String, map: JsonValue, skeletonData: SkeletonData) {
//		val scale = this.scale
//		val timelines = Array()
//		var duration = 0f
//
//		// Slot timelines.
//		run {
//			var slotMap = map.getChild("slots")
//			while (slotMap != null) {
//				val slotIndex = skeletonData.findSlotIndex(slotMap!!.name)
//				if (slotIndex == -1) throw Exception("Slot not found: " + slotMap!!.name)
//
//				var timelineMap = slotMap!!.child
//				while (timelineMap != null) {
//					val timelineName = timelineMap!!.name
//					if (timelineName == "color") {
//						val timeline = ColorTimeline(timelineMap!!.size)
//						timeline.slotIndex = slotIndex
//
//						var frameIndex = 0
//						var valueMap = timelineMap!!.child
//						while (valueMap != null) {
//							val color = Color.fromStr(valueMap!!.getString("color"))
//							timeline.setFrame(frameIndex, valueMap!!.getFloat("time"), color.r, color.g, color.b, color.a)
//							readCurve(timeline, frameIndex, valueMap)
//							frameIndex++
//							valueMap = valueMap!!.next
//						}
//						timelines.add(timeline)
//						duration = maxOf(duration, timeline.frames[timeline.frameCount * 5 - 5])
//
//					} else if (timelineName == "attachment") {
//						val timeline = AttachmentTimeline(timelineMap!!.size)
//						timeline.slotIndex = slotIndex
//
//						var frameIndex = 0
//						var valueMap = timelineMap!!.child
//						while (valueMap != null) {
//							timeline.setFrame(frameIndex++, valueMap!!.getFloat("time"), valueMap!!.getString("name"))
//							valueMap = valueMap!!.next
//						}
//						timelines.add(timeline)
//						duration = maxOf(duration, timeline.frames[timeline.frameCount - 1])
//					} else
//						throw RuntimeException("Invalid timeline type for a slot: " + timelineName + " (" + slotMap!!.name + ")")
//					timelineMap = timelineMap!!.next
//				}
//				slotMap = slotMap!!.next
//			}
//		}
//
//		// Bone timelines.
//		var boneMap = map.getChild("bones")
//		while (boneMap != null) {
//			val boneIndex = skeletonData.findBoneIndex(boneMap!!.name)
//			if (boneIndex == -1) throw Exception("Bone not found: " + boneMap!!.name)
//
//			var timelineMap = boneMap!!.child
//			while (timelineMap != null) {
//				val timelineName = timelineMap!!.name
//				if (timelineName == "rotate") {
//					val timeline = RotateTimeline(timelineMap!!.size)
//					timeline.boneIndex = boneIndex
//
//					var frameIndex = 0
//					var valueMap = timelineMap!!.child
//					while (valueMap != null) {
//						timeline.setFrame(frameIndex, valueMap!!.getFloat("time"), valueMap!!.getFloat("angle"))
//						readCurve(timeline, frameIndex, valueMap)
//						frameIndex++
//						valueMap = valueMap!!.next
//					}
//					timelines.add(timeline)
//					duration = maxOf(duration, timeline.frames[timeline.frameCount * 2 - 2])
//
//				} else if (timelineName == "translate" || timelineName == "scale") {
//					val timeline: TranslateTimeline
//					var timelineScale = 1f
//					if (timelineName == "scale")
//						timeline = ScaleTimeline(timelineMap!!.size)
//					else {
//						timeline = TranslateTimeline(timelineMap!!.size)
//						timelineScale = scale
//					}
//					timeline.boneIndex = boneIndex
//
//					var frameIndex = 0
//					var valueMap = timelineMap!!.child
//					while (valueMap != null) {
//						val x = valueMap!!.getFloat("x", 0)
//						val y = valueMap!!.getFloat("y", 0)
//						timeline.setFrame(frameIndex, valueMap!!.getFloat("time"), x * timelineScale, y * timelineScale)
//						readCurve(timeline, frameIndex, valueMap)
//						frameIndex++
//						valueMap = valueMap!!.next
//					}
//					timelines.add(timeline)
//					duration = maxOf(duration, timeline.frames[timeline.frameCount * 3 - 3])
//
//				} else
//					throw RuntimeException("Invalid timeline type for a bone: " + timelineName + " (" + boneMap!!.name + ")")
//				timelineMap = timelineMap!!.next
//			}
//			boneMap = boneMap!!.next
//		}
//
//		// IK timelines.
//		var ikMap = map.getChild("ik")
//		while (ikMap != null) {
//			val ikConstraint = skeletonData.findIkConstraint(ikMap!!.name)
//			val timeline = IkConstraintTimeline(ikMap!!.size)
//			timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(ikConstraint)
//			var frameIndex = 0
//			var valueMap = ikMap!!.child
//			while (valueMap != null) {
//				timeline.setFrame(frameIndex, valueMap!!.getFloat("time"), valueMap!!.getFloat("mix"),
//						if (valueMap!!.getBoolean("bendPositive")) 1 else -1)
//				readCurve(timeline, frameIndex, valueMap)
//				frameIndex++
//				valueMap = valueMap!!.next
//			}
//			timelines.add(timeline)
//			duration = maxOf(duration, timeline.frames[timeline.frameCount * 3 - 3])
//			ikMap = ikMap!!.next
//		}
//
//		// Ffd timelines.
//		var ffdMap = map.getChild("ffd")
//		while (ffdMap != null) {
//			val skin = skeletonData.findSkin(ffdMap!!.name) ?: throw Exception("Skin not found: " + ffdMap!!.name)
//			var slotMap = ffdMap!!.child
//			while (slotMap != null) {
//				val slotIndex = skeletonData.findSlotIndex(slotMap!!.name)
//				if (slotIndex == -1) throw Exception("Slot not found: " + slotMap!!.name)
//				var meshMap = slotMap!!.child
//				while (meshMap != null) {
//					val timeline = FfdTimeline(meshMap!!.size)
//					val attachment = skin.getAttachment(slotIndex, meshMap!!.name) ?: throw Exception("Ffd attachment not found: " + meshMap!!.name)
//					timeline.slotIndex = slotIndex
//					timeline.attachment = attachment
//
//					val vertexCount: Int
//					if (attachment is MeshAttachment)
//						vertexCount = attachment.vertices.size
//					else
//						vertexCount = (attachment as WeightedMeshAttachment).weights.size / 3 * 2
//
//					var frameIndex = 0
//					var valueMap = meshMap!!.child
//					while (valueMap != null) {
//						val vertices: FloatArray
//						val verticesValue = valueMap!!.get("vertices")
//						if (verticesValue == null) {
//							if (attachment is MeshAttachment)
//								vertices = attachment.vertices
//							else
//								vertices = FloatArray(vertexCount)
//						} else {
//							vertices = FloatArray(vertexCount)
//							val start = valueMap!!.getInt("offset", 0)
//							System.arraycopy(verticesValue!!.asFloatArray(), 0, vertices, start, verticesValue!!.size)
//							if (scale != 1f) {
//								var i = start
//								val n = i + verticesValue!!.size
//								while (i < n) {
//									vertices[i] *= scale
//									i++
//								}
//							}
//							if (attachment is MeshAttachment) {
//								val meshVertices = attachment.vertices
//								for (i in 0..vertexCount - 1)
//									vertices[i] += meshVertices[i]
//							}
//						}
//
//						timeline.setFrame(frameIndex, valueMap!!.getFloat("time"), vertices)
//						readCurve(timeline, frameIndex, valueMap)
//						frameIndex++
//						valueMap = valueMap!!.next
//					}
//					timelines.add(timeline)
//					duration = maxOf(duration, timeline.frames[timeline.frameCount - 1])
//					meshMap = meshMap!!.next
//				}
//				slotMap = slotMap!!.next
//			}
//			ffdMap = ffdMap!!.next
//		}
//
//		// Draw order timeline.
//		var drawOrdersMap = map.get("drawOrder")
//		if (drawOrdersMap == null) drawOrdersMap = map.get("draworder")
//		if (drawOrdersMap != null) {
//			val timeline = DrawOrderTimeline(drawOrdersMap!!.size)
//			val slotCount = skeletonData.slots.size
//			var frameIndex = 0
//			var drawOrderMap = drawOrdersMap!!.child
//			while (drawOrderMap != null) {
//				var drawOrder: IntArray? = null
//				val offsets = drawOrderMap!!.get("offsets")
//				if (offsets != null) {
//					drawOrder = IntArray(slotCount)
//					for (i in slotCount - 1 downTo 0)
//						drawOrder[i] = -1
//					val unchanged = IntArray(slotCount - offsets!!.size)
//					var originalIndex = 0
//					var unchangedIndex = 0
//					var offsetMap = offsets!!.child
//					while (offsetMap != null) {
//						val slotIndex = skeletonData.findSlotIndex(offsetMap!!.getString("slot"))
//						if (slotIndex == -1) throw Exception("Slot not found: " + offsetMap!!.getString("slot"))
//						// Collect unchanged items.
//						while (originalIndex != slotIndex)
//							unchanged[unchangedIndex++] = originalIndex++
//						// Set changed items.
//						drawOrder[originalIndex + offsetMap!!.getInt("offset")] = originalIndex++
//						offsetMap = offsetMap!!.next
//					}
//					// Collect remaining unchanged items.
//					while (originalIndex < slotCount)
//						unchanged[unchangedIndex++] = originalIndex++
//					// Fill in unchanged items.
//					for (i in slotCount - 1 downTo 0)
//						if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex]
//				}
//				timeline.setFrame(frameIndex++, drawOrderMap!!.getFloat("time"), drawOrder)
//				drawOrderMap = drawOrderMap!!.next
//			}
//			timelines.add(timeline)
//			duration = maxOf(duration, timeline.frames[timeline.frameCount - 1])
//		}
//
//		// Event timeline.
//		val eventsMap = map.get("events")
//		if (eventsMap != null) {
//			val timeline = EventTimeline(eventsMap!!.size)
//			var frameIndex = 0
//			var eventMap = eventsMap!!.child
//			while (eventMap != null) {
//				val eventData = skeletonData.findEvent(eventMap!!.getString("name")) ?: throw Exception("Event not found: " + eventMap!!.getString("name"))
//				val event = Event(eventMap!!.getFloat("time"), eventData)
//				event.int = eventMap!!.getInt("int", eventData.int)
//				event.float = eventMap!!.getFloat("float", eventData.float)
//				event.string = eventMap!!.getString("string", eventData.string)
//				timeline.setFrame(frameIndex++, event)
//				eventMap = eventMap!!.next
//			}
//			timelines.add(timeline)
//			duration = maxOf(duration, timeline.frames[timeline.frameCount - 1])
//		}
//
//		timelines.shrink()
//		skeletonData.animations.add(Animation(name, timelines, duration))
//	}
//
//	internal fun readCurve(timeline: CurveTimeline, frameIndex: Int, valueMap: JsonValue) {
//		val curve = valueMap.get("curve") ?: return
//		if (curve!!.isString() && curve!!.asString().equals("stepped"))
//			timeline.setStepped(frameIndex)
//		else if (curve!!.isArray()) {
//			timeline.setCurve(frameIndex, curve!!.getFloat(0), curve!!.getFloat(1), curve!!.getFloat(2), curve!!.getFloat(3))
//		}
//	}
//
//	internal class LinkedMesh(
//			val mesh: Attachment,
//			val skin: String?,
//			val slotIndex: Int,
//			val parent: String
//	)
//}
