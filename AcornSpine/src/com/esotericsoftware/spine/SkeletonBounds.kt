/*
 * Spine Runtimes Software License
 * Version 2.3
 *
 * Copyright (c) 2013-2015, Esoteric Software
 * All rights reserved.
 *
 * You are granted a perpetual, non-exclusive, non-sublicensable and
 * non-transferable license to use, install, execute and perform the Spine
 * Runtimes Software (the "Software") and derivative works solely for personal
 * or internal use. Without the written permission of Esoteric Software (see
 * Section 2 of the Spine Software License Agreement), you may not (a) modify,
 * translate, adapt or otherwise create derivative works, improvements of the
 * Software or develop new applications using the Software or (b) remove,
 * delete, alter or obscure any trademarks or any copyright, trademark, patent
 * or other intellectual property or proprietary rights notices on or in the
 * Software, including any copy thereof. Redistributions in binary or source
 * form must include this license and terms.
 *
 * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright 2016 Nicholas Bilyk
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Copyright 2016 Nicholas Bilyk
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * Spine Runtimes Software License
 * Version 2.3
 *
 * Copyright (c) 2013-2015, Esoteric Software
 * All rights reserved.
 *
 * You are granted a perpetual, non-exclusive, non-sublicensable and
 * non-transferable license to use, install, execute and perform the Spine
 * Runtimes Software (the "Software") and derivative works solely for personal
 * or internal use. Without the written permission of Esoteric Software (see
 * Section 2 of the Spine Software License Agreement), you may not (a) modify,
 * translate, adapt or otherwise create derivative works, improvements of the
 * Software or develop new applications using the Software or (b) remove,
 * delete, alter or obscure any trademarks or any copyright, trademark, patent
 * or other intellectual property or proprietary rights notices on or in the
 * Software, including any copy thereof. Redistributions in binary or source
 * form must include this license and terms.
 *
 * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Spine Runtimes Software License
 * Version 2.3
 *
 * Copyright (c) 2013-2015, Esoteric Software
 * All rights reserved.
 *
 * You are granted a perpetual, non-exclusive, non-sublicensable and
 * non-transferable license to use, install, execute and perform the Spine
 * Runtimes Software (the "Software") and derivative works solely for personal
 * or internal use. Without the written permission of Esoteric Software (see
 * Section 2 of the Spine Software License Agreement), you may not (a) modify,
 * translate, adapt or otherwise create derivative works, improvements of the
 * Software or develop new applications using the Software or (b) remove,
 * delete, alter or obscure any trademarks or any copyright, trademark, patent
 * or other intellectual property or proprietary rights notices on or in the
 * Software, including any copy thereof. Redistributions in binary or source
 * form must include this license and terms.
 *
 * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Spine Runtimes Software License
 * Version 2.3
 *
 * Copyright (c) 2013-2015, Esoteric Software
 * All rights reserved.
 *
 * You are granted a perpetual, non-exclusive, non-sublicensable and
 * non-transferable license to use, install, execute and perform the Spine
 * Runtimes Software (the "Software") and derivative works solely for personal
 * or internal use. Without the written permission of Esoteric Software (see
 * Section 2 of the Spine Software License Agreement), you may not (a) modify,
 * translate, adapt or otherwise create derivative works, improvements of the
 * Software or develop new applications using the Software or (b) remove,
 * delete, alter or obscure any trademarks or any copyright, trademark, patent
 * or other intellectual property or proprietary rights notices on or in the
 * Software, including any copy thereof. Redistributions in binary or source
 * form must include this license and terms.
 *
 * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright 2016 Nicholas Bilyk
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

///*
// * Copyright 2016 Nicholas Bilyk
// *
// * Licensed under the Apache License, Version 2.0 (the "License");
// * you may not use this file except in compliance with the License.
// * You may obtain a copy of the License at
// *
// *     http://www.apache.org/licenses/LICENSE-2.0
// *
// * Unless required by applicable law or agreed to in writing, software
// * distributed under the License is distributed on an "AS IS" BASIS,
// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// * See the License for the specific language governing permissions and
// * limitations under the License.
// */
//
//package com.esotericsoftware.spine
//
//import com.acornui.collection.Pool
//import com.esotericsoftware.spine.attachments.Attachment
//import com.esotericsoftware.spine.attachments.BoundingBoxAttachment
//
//
//class SkeletonBounds {
//	var minX: Float = 0f
//		private set
//	var minY: Float = 0f
//		private set
//	var maxX: Float = 0f
//		private set
//	var maxY: Float = 0f
//		private set
//	val boundingBoxes: MutableList<BoundingBoxAttachment> = ArrayList()
//	val polygons: MutableList<ArrayList<Float>> = ArrayList()
//
//	private val polygonPool = Pool() { ArrayList<Float>() }
//
//	fun update(skeleton: Skeleton, updateAabb: Boolean) {
//		val boundingBoxes = this.boundingBoxes
//		val polygons = this.polygons
//		val slots = skeleton.slots
//		val slotCount = slots.size
//
//		boundingBoxes.clear()
//		polygonPool.freeAll(polygons)
//		polygons.clear()
//
//		for (i in 0..slotCount - 1) {
//			val slot = slots[i]
//			val attachment = slot.attachment
//			if (attachment is BoundingBoxAttachment) {
//				boundingBoxes.add(attachment)
//
//				val polygon = polygonPool.obtain()
//				polygons.add(polygon)
//				val vertexCount = attachment.vertices.size
//				polygon.size = vertexCount
//
//				attachment.computeWorldVertices(slot.bone, polygon.items)
//			}
//		}
//
//		if (updateAabb) aabbCompute()
//	}
//
//	private fun aabbCompute() {
//		var minX = INT_MAX_VALUE.toFloat()
//		var minY = INT_MAX_VALUE.toFloat()
//		var maxX = INT_MIN_VALUE.toFloat()
//		var maxY = INT_MIN_VALUE.toFloat()
//		val polygons = this.polygons
//		var i = 0
//		val n = polygons.size
//		while (i < n) {
//			val polygon = polygons[i]
//			val vertices = polygon
//			var ii = 0
//			val nn = polygon.size
//			while (ii < nn) {
//				val x = vertices[ii]
//				val y = vertices[ii + 1]
//				minX = minOf(minX, x)
//				minY = minOf(minY, y)
//				maxX = maxOf(maxX, x)
//				maxY = maxOf(maxY, y)
//				ii += 2
//			}
//			i++
//		}
//		this.minX = minX
//		this.minY = minY
//		this.maxX = maxX
//		this.maxY = maxY
//	}
//
//	/** Returns true if the axis aligned bounding box contains the point.  */
//	fun aabbContainsPoint(x: Float, y: Float): Boolean {
//		return x >= minX && x <= maxX && y >= minY && y <= maxY
//	}
//
//	/** Returns true if the axis aligned bounding box intersects the line segment.  */
//	fun aabbIntersectsSegment(x1: Float, y1: Float, x2: Float, y2: Float): Boolean {
//		val minX = this.minX
//		val minY = this.minY
//		val maxX = this.maxX
//		val maxY = this.maxY
//		if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY)
//			return false
//		val m = (y2 - y1) / (x2 - x1)
//		var y = m * (minX - x1) + y1
//		if (y > minY && y < maxY) return true
//		y = m * (maxX - x1) + y1
//		if (y > minY && y < maxY) return true
//		var x = (minY - y1) / m + x1
//		if (x > minX && x < maxX) return true
//		x = (maxY - y1) / m + x1
//		if (x > minX && x < maxX) return true
//		return false
//	}
//
//	/** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds.  */
//	fun aabbIntersectsSkeleton(bounds: SkeletonBounds): Boolean {
//		return minX < bounds.maxX && maxX > bounds.minX && minY < bounds.maxY && maxY > bounds.minY
//	}
//
//	/** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more
//	 * efficient to only call this method if [.aabbContainsPoint] returns true.  */
//	fun containsPoint(x: Float, y: Float): BoundingBoxAttachment? {
//		val polygons = this.polygons
//		var i = 0
//		val n = polygons.size
//		while (i < n) {
//			if (containsPoint(polygons[i], x, y)) return boundingBoxes[i]
//			i++
//		}
//		return null
//	}
//
//	/** Returns true if the polygon contains the point.  */
//	fun containsPoint(polygon: FloatArray, x: Float, y: Float): Boolean {
//		val vertices = polygon
//		val nn = polygon.size
//
//		var prevIndex = nn - 2
//		var inside = false
//		var ii = 0
//		while (ii < nn) {
//			val vertexY = vertices[ii + 1]
//			val prevY = vertices[prevIndex + 1]
//			if (vertexY < y && prevY >= y || prevY < y && vertexY >= y) {
//				val vertexX = vertices[ii]
//				if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) inside = !inside
//			}
//			prevIndex = ii
//			ii += 2
//		}
//		return inside
//	}
//
//	/** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it
//	 * is usually more efficient to only call this method if [.aabbIntersectsSegment] returns
//	 * true.  */
//	fun intersectsSegment(x1: Float, y1: Float, x2: Float, y2: Float): BoundingBoxAttachment? {
//		val polygons = this.polygons
//		var i = 0
//		val n = polygons.size
//		while (i < n) {
//			if (intersectsSegment(polygons[i], x1, y1, x2, y2)) return boundingBoxes[i]
//			i++
//		}
//		return null
//	}
//
//	/** Returns true if the polygon contains any part of the line segment.  */
//	fun intersectsSegment(polygon: FloatArray, x1: Float, y1: Float, x2: Float, y2: Float): Boolean {
//		val vertices = polygon
//		val nn = polygon.size
//
//		val width12 = x1 - x2
//		val height12 = y1 - y2
//		val det1 = x1 * y2 - y1 * x2
//		var x3 = vertices[nn - 2]
//		var y3 = vertices[nn - 1]
//		var ii = 0
//		while (ii < nn) {
//			val x4 = vertices[ii]
//			val y4 = vertices[ii + 1]
//			val det2 = x3 * y4 - y3 * x4
//			val width34 = x3 - x4
//			val height34 = y3 - y4
//			val det3 = width12 * height34 - height12 * width34
//			val x = (det1 * width34 - width12 * det2) / det3
//			if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {
//				val y = (det1 * height34 - height12 * det2) / det3
//				if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1)) return true
//			}
//			x3 = x4
//			y3 = y4
//			ii += 2
//		}
//		return false
//	}
//
//	val width: Float
//		get() = maxX - minX
//
//	val height: Float
//		get() = maxY - minY
//
//	/** Returns the polygon for the specified bounding box, or null.  */
//	fun getPolygon(boundingBox: BoundingBoxAttachment): FloatArray? {
//		val index = boundingBoxes.indexOf(boundingBox)
//		return if (index == -1) null else polygons[index]
//	}
//}
